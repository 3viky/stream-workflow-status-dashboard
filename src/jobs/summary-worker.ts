/**
 * Background worker for processing intelligent summary generation jobs
 */

import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { execSync } from 'node:child_process';
import { simpleGit } from 'simple-git';
import type Database from 'better-sqlite3';

let isProcessing = false;

interface SummaryJob {
  id: number;
  stream_id: string;
  stream_number: string;
  stream_title: string;
  stream_category: string;
  stream_branch: string;
  stream_worktree_path: string;
  stream_created_at: string;
  stream_completed_at: string | null;
  user_summary: string;
  history_file_path: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  attempts: number;
  max_attempts: number;
  error_message: string | null;
}

function getNextJob(db: Database.Database): SummaryJob | null {
  const stmt = db.prepare(`
    SELECT * FROM summary_jobs
    WHERE status = 'pending'
      AND attempts < max_attempts
    ORDER BY created_at ASC
    LIMIT 1
  `);

  return stmt.get() as SummaryJob | null;
}

function markJobProcessing(db: Database.Database, jobId: number): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = 'processing',
        started_at = datetime('now'),
        attempts = attempts + 1
    WHERE id = ?
  `);

  stmt.run(jobId);
}

function markJobCompleted(db: Database.Database, jobId: number): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = 'completed',
        completed_at = datetime('now')
    WHERE id = ?
  `);

  stmt.run(jobId);
}

function markJobFailed(db: Database.Database, jobId: number, error: string): void {
  const stmt = db.prepare(`
    UPDATE summary_jobs
    SET status = CASE
          WHEN attempts >= max_attempts THEN 'failed'
          ELSE 'pending'
        END,
        error_message = ?
    WHERE id = ?
  `);

  stmt.run(error, jobId);
}

async function generateIntelligentSummary(job: SummaryJob, projectRoot: string): Promise<string> {
  const prompt = `You are analyzing a completed development stream to generate a retirement report.

Stream Details:
- ID: ${job.stream_id}
- Number: ${job.stream_number}
- Title: ${job.stream_title}
- Category: ${job.stream_category}
- Branch: ${job.stream_branch}
- Worktree: ${job.stream_worktree_path}
- Created: ${job.stream_created_at}
- Completed: ${job.stream_completed_at || 'Recently'}

User-provided summary: ${job.user_summary}

Task: Generate a detailed 2-4 paragraph summary of what was accomplished in this stream.
Look at the git commits, changes made, and any documentation.
Focus on:
1. What features/fixes were implemented
2. What problems were solved
3. Technical approach or key decisions
4. Impact on the codebase

Write in past tense, be specific and technical. Do NOT use phrases like "this stream" or "the developer".
Just describe what was done.`;

  const result = execSync(`claude -p "${prompt.replace(/"/g, '\\"')}"`, {
    encoding: 'utf-8',
    cwd: projectRoot,
    timeout: 60000,
    stdio: ['pipe', 'pipe', 'pipe'],
  });

  return result.trim();
}

async function updateHistoryFile(
  filePath: string,
  oldSummary: string,
  newSummary: string,
  projectRoot: string
): Promise<void> {
  if (!existsSync(filePath)) {
    throw new Error(`History file not found: ${filePath}`);
  }

  const content = readFileSync(filePath, 'utf-8');

  const updatedContent = content.replace(
    `## Summary\n\n${oldSummary}`,
    `## Summary\n\n${newSummary}\n\n---\n\n*Summary generated by Claude on ${new Date().toISOString()}*`
  );

  if (updatedContent === content) {
    throw new Error('Summary replacement failed - old summary not found in file');
  }

  writeFileSync(filePath, updatedContent, 'utf-8');

  const git = simpleGit(projectRoot);
  await git.add(filePath);
  await git.commit(`docs: Update intelligent summary for ${filePath}`, ['--no-verify']);
  await git.push('origin', 'main');

  console.log(`[summary-worker] Updated and pushed ${filePath}`);
}

export async function processJob(
  db: Database.Database,
  job: SummaryJob,
  projectRoot: string
): Promise<void> {
  console.log(`[summary-worker] Processing job ${job.id} for stream ${job.stream_id}`);

  markJobProcessing(db, job.id);

  try {
    const intelligentSummary = await generateIntelligentSummary(job, projectRoot);

    if (intelligentSummary.length < 50) {
      throw new Error('Generated summary too short');
    }

    await updateHistoryFile(job.history_file_path, job.user_summary, intelligentSummary, projectRoot);

    markJobCompleted(db, job.id);

    console.log(`[summary-worker] Completed job ${job.id} for stream ${job.stream_id}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`[summary-worker] Job ${job.id} failed:`, errorMessage);

    markJobFailed(db, job.id, errorMessage);

    if (job.attempts + 1 >= job.max_attempts) {
      console.error(`[summary-worker] Job ${job.id} exhausted all retry attempts`);
    }
  }
}

function isMaintenanceWindow(): boolean {
  const now = new Date();
  const hour = now.getHours();
  return hour >= 3 && hour < 6;
}

export async function processPendingJobs(
  db: Database.Database,
  projectRoot: string
): Promise<number> {
  if (isProcessing) {
    console.log('[summary-worker] Skipping: previous job batch still processing');
    return 0;
  }

  isProcessing = true;

  try {
    let processed = 0;

    if (!isMaintenanceWindow()) {
      const now = new Date();
      const hour = now.getHours();
      const nextWindow = hour < 3 ? `in ${3 - hour} hours` : 'tomorrow at 3am';
      console.log(
        `[summary-worker] Outside maintenance window (3am-6am). Current time: ${now.toLocaleTimeString()}. Next window: ${nextWindow}`
      );
      return 0;
    }

    while (true) {
      const job = getNextJob(db);
      if (!job) {
        break;
      }

      console.log(
        `[summary-worker] Processing job ${job.id}/${job.stream_id} (attempt ${job.attempts + 1}/${job.max_attempts})`
      );
      await processJob(db, job, projectRoot);
      processed++;

      await new Promise((resolve) => setTimeout(resolve, 2000));
    }

    return processed;
  } finally {
    isProcessing = false;
  }
}

export async function startWorker(
  db: Database.Database,
  projectRoot: string,
  pollInterval = 10000
): Promise<void> {
  console.log('[summary-worker] Starting background worker...');
  console.log(`[summary-worker] Poll interval: ${pollInterval}ms`);
  console.log('[summary-worker] Maintenance window: 3am-6am local time');

  while (true) {
    try {
      const processed = await processPendingJobs(db, projectRoot);

      if (processed > 0) {
        console.log(`[summary-worker] Processed ${processed} jobs`);
      }

      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    } catch (error) {
      console.error('[summary-worker] Worker error:', error);
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
  }
}
